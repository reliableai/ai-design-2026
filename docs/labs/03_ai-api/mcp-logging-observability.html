<!DOCTYPE html>
<!--
  Content by Fabio Casati
  https://www.linkedin.com/in/sphoebs/
  https://x.com/sphoebs
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP Logging and Observability</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=JetBrains+Mono:wght@400;500&family=Sora:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <link rel="stylesheet" href="../../lecture-style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>

<nav>
    <div class="logo">MCP Observability</div>
    <ul>
        <li><a href="#intro">Intro</a></li>
        <li><a href="#mcp-logging">1. MCP Logging</a></li>
        <li><a href="#notifications">2. Notifications</a></li>
        <li><a href="#gaps">3. Gaps</a></li>
        <li><a href="#opentelemetry">4. OpenTelemetry</a></li>
    </ul>
</nav>

<main>

    <!-- TITLE -->
    <div class="title-section" id="intro">
        <h1>MCP Logging and Observability</h1>
        <p class="subtitle">What MCP provides today and what's missing for full-stack observability</p>
    </div>

    <p>This document covers how the Model Context Protocol (MCP) supports logging and observability, including its notification system, and provides context on OpenTelemetry as the broader observability standard.</p>

    <p><a href="ai_tools_integration.html">← Back to AI Tools Integration</a></p>

    <!-- SECTION 1 -->
    <section id="mcp-logging">
        <div class="section-number">01 / MCP LOGGING</div>
        <h2>MCP Logging Primitive</h2>

        <p>MCP includes a built-in <strong>Logging</strong> utility primitive that enables servers to send structured log messages to clients for debugging and monitoring purposes.</p>

        <h3>Capability Declaration</h3>

        <p>Servers that emit log messages must declare the <code>logging</code> capability during initialization:</p>

        <pre><code class="language-json">{
  "capabilities": {
    "logging": {}
  }
}</code></pre>

        <h3>Log Levels</h3>

        <p>MCP logging uses severity levels aligned with RFC-5424 syslog conventions:</p>

        <table>
            <thead>
                <tr><th>Level</th><th>Description</th></tr>
            </thead>
            <tbody>
                <tr><td><code>debug</code></td><td>Detailed debugging information</td></tr>
                <tr><td><code>info</code></td><td>Informational messages</td></tr>
                <tr><td><code>notice</code></td><td>Normal but significant conditions</td></tr>
                <tr><td><code>warning</code></td><td>Warning conditions</td></tr>
                <tr><td><code>error</code></td><td>Error conditions</td></tr>
                <tr><td><code>critical</code></td><td>Critical conditions</td></tr>
                <tr><td><code>alert</code></td><td>Action must be taken immediately</td></tr>
                <tr><td><code>emergency</code></td><td>System is unusable</td></tr>
            </tbody>
        </table>

        <h3>Protocol Flow</h3>

        <ol>
            <li><strong>Client sets verbosity</strong>: Client sends <code>logging/setLevel</code> request specifying the minimum log level (e.g., <code>info</code>)</li>
            <li><strong>Server acknowledges</strong>: Server responds with an empty result confirming the level</li>
            <li><strong>Server emits logs</strong>: Server sends <code>notifications/message</code> containing logs at or above the configured level</li>
            <li><strong>Dynamic adjustment</strong>: Client can issue another <code>logging/setLevel</code> to change verbosity at any time</li>
        </ol>

        <h3>Log Message Structure</h3>

        <pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "notifications/message",
  "params": {
    "level": "error",
    "logger": "router",
    "data": {
      "error_code": 500,
      "details": "Internal Server Error"
    }
  }
}</code></pre>

        <p>Fields:</p>
        <ul>
            <li><strong>level</strong> (required): Severity level of the message</li>
            <li><strong>logger</strong> (optional): Name of the logger/module issuing the message</li>
            <li><strong>data</strong> (required): The log payload—any JSON-serializable value</li>
        </ul>

        <div class="content-card">
            <h4>Important: STDIO Transport Caveat</h4>
            <p>When running MCP servers over STDIO transport, avoid writing logs directly to stdout/stderr as this can disrupt the MCP protocol stream. MCP itself relies on STDIO for structured communication, so mixing logs with protocol messages can cause parsing errors or disconnections.</p>
        </div>
    </section>

    <!-- SECTION 2 -->
    <section id="notifications">
        <div class="section-number">02 / NOTIFICATIONS</div>
        <h2>MCP Notifications</h2>

        <p>Notifications are a core messaging primitive in MCP, built on JSON-RPC 2.0. Unlike requests, notifications are one-way messages that do not expect a response.</p>

        <h3>Notification Types</h3>

        <p>MCP uses notifications for several purposes:</p>

        <table>
            <thead>
                <tr><th>Notification</th><th>Purpose</th></tr>
            </thead>
            <tbody>
                <tr><td><code>notifications/message</code></td><td>Log messages from server to client</td></tr>
                <tr><td><code>notifications/progress</code></td><td>Progress updates for long-running operations</td></tr>
                <tr><td><code>notifications/resources/list_changed</code></td><td>Server's available resources have changed</td></tr>
                <tr><td><code>notifications/resources/updated</code></td><td>A specific subscribed resource has changed</td></tr>
                <tr><td><code>notifications/tools/list_changed</code></td><td>Server's available tools have changed</td></tr>
                <tr><td><code>notifications/prompts/list_changed</code></td><td>Server's available prompts have changed</td></tr>
                <tr><td><code>notifications/cancelled</code></td><td>A request has been cancelled</td></tr>
            </tbody>
        </table>

        <h3>Progress Tracking</h3>

        <p>For long-running operations, MCP supports progress notifications:</p>

        <pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "notifications/progress",
  "params": {
    "progressToken": "abc123",
    "progress": 50,
    "total": 100,
    "message": "Processing records..."
  }
}</code></pre>

        <p>The sender includes a <code>progressToken</code> in the request metadata, and the receiver can emit progress updates referencing that token.</p>
    </section>

    <!-- SECTION 3 -->
    <section id="gaps">
        <div class="section-number">03 / GAPS</div>
        <h2>What MCP Doesn't Include (Yet)</h2>

        <p>MCP's current logging primitive covers basic structured logging but lacks deeper observability features:</p>

        <ul>
            <li><strong>Distributed tracing</strong>: No built-in support for trace context propagation across MCP calls</li>
            <li><strong>Metrics collection</strong>: No primitives for exposing counters, gauges, or histograms</li>
            <li><strong>Span correlation</strong>: No mechanism to connect MCP server operations to broader application traces</li>
        </ul>

        <div class="thesis-block">
            <div class="label">Active Proposal</div>
            <p>There is an <a href="https://github.com/modelcontextprotocol/modelcontextprotocol/discussions/269">active proposal</a> to add OpenTelemetry trace support to MCP, which would allow servers to emit OTel spans back to clients, enabling full-stack observability in agentic workflows.</p>
        </div>
    </section>

    <!-- SECTION 4 -->
    <section id="opentelemetry">
        <div class="section-number">04 / OPENTELEMETRY</div>
        <h2>OpenTelemetry Overview</h2>

        <p>OpenTelemetry (OTel) is an open-source observability framework under the Cloud Native Computing Foundation (CNCF) that provides a unified, vendor-neutral approach to collecting telemetry data.</p>

        <h3>The Three Pillars (Plus One)</h3>

        <p>OpenTelemetry standardizes collection of four observability signals:</p>

        <table>
            <thead>
                <tr><th>Signal</th><th>Description</th><th>Use Case</th></tr>
            </thead>
            <tbody>
                <tr><td><strong>Traces</strong></td><td>Records the path of a request through distributed services</td><td>Understanding request flow, identifying bottlenecks</td></tr>
                <tr><td><strong>Metrics</strong></td><td>Quantitative measurements (counters, gauges, histograms)</td><td>Monitoring health, alerting on thresholds</td></tr>
                <tr><td><strong>Logs</strong></td><td>Timestamped records of discrete events</td><td>Debugging, audit trails</td></tr>
                <tr><td><strong>Profiles</strong></td><td>CPU/memory usage snapshots (newer addition)</td><td>Performance optimization</td></tr>
            </tbody>
        </table>

        <h3>Key Concepts</h3>

        <h4>Spans and Traces</h4>
        <ul>
            <li>A <strong>span</strong> represents a single unit of work (e.g., an HTTP request, a database query)</li>
            <li>A <strong>trace</strong> is a collection of spans forming the complete journey of a request</li>
            <li>Spans contain: name, start/end timestamps, attributes, status, and parent context</li>
        </ul>

        <h4>Context Propagation</h4>
        <ul>
            <li>OTel automatically propagates trace context (trace ID, span ID) across service boundaries</li>
            <li>This enables correlation of logs, metrics, and traces from different services participating in the same request</li>
        </ul>

        <h4>Resources</h4>
        <ul>
            <li>Metadata describing the entity producing telemetry (service name, version, host, etc.)</li>
            <li>Automatically attached to all signals for consistent attribution</li>
        </ul>

        <h3>Architecture Components</h3>

        <pre><code>┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Application    │     │  OTel Collector │     │   Backend       │
│  (SDK + API)    │────▶│  (optional)     │────▶│  (Jaeger,       │
│                 │     │                 │     │   Prometheus,   │
└─────────────────┘     └─────────────────┘     │   etc.)         │
                                                └─────────────────┘</code></pre>

        <ul>
            <li><strong>API</strong>: Defines instrumentation interface (vendor-agnostic)</li>
            <li><strong>SDK</strong>: Implements the API, handles sampling, batching, export</li>
            <li><strong>Collector</strong>: Optional middleware for receiving, processing, and routing telemetry</li>
            <li><strong>Exporters</strong>: Send data to backends (Jaeger, Prometheus, Zipkin, vendor solutions)</li>
        </ul>

        <h3>Why It Matters for MCP</h3>

        <p>As agentic AI applications grow more complex—with multiple MCP calls, LLM interactions, and tool invocations—the ability to trace execution end-to-end becomes critical. Without tracing support:</p>

        <ul>
            <li>MCP servers are "black boxes" in observability dashboards</li>
            <li>Debugging multi-step agent workflows requires correlating disconnected logs</li>
            <li>Performance analysis across the agent→MCP→external service chain is difficult</li>
        </ul>

        <p>The proposed OTel integration would allow MCP servers to emit spans that clients can forward to their observability backends, creating unified traces across the entire agent execution.</p>
    </section>

    <!-- REFERENCES -->
    <section id="references">
        <h2>References</h2>

        <h3>MCP Documentation</h3>

        <table>
            <thead>
                <tr><th>Topic</th><th>URL</th></tr>
            </thead>
            <tbody>
                <tr><td>Architecture Overview</td><td><a href="https://modelcontextprotocol.io/docs/learn/architecture">modelcontextprotocol.io/docs/learn/architecture</a></td></tr>
                <tr><td>Logging Specification</td><td><a href="https://spec.modelcontextprotocol.io/specification/2024-11-05/server/utilities/logging/">spec.modelcontextprotocol.io/.../logging/</a></td></tr>
                <tr><td>Progress Tracking</td><td><a href="https://spec.modelcontextprotocol.io/specification/draft/basic/utilities/progress/">spec.modelcontextprotocol.io/.../progress/</a></td></tr>
                <tr><td>Resources & Notifications</td><td><a href="https://modelcontextprotocol.info/docs/concepts/resources/">modelcontextprotocol.info/docs/concepts/resources/</a></td></tr>
                <tr><td>OTel Integration Proposal</td><td><a href="https://github.com/modelcontextprotocol/modelcontextprotocol/discussions/269">github.com/.../discussions/269</a></td></tr>
            </tbody>
        </table>

        <h3>OpenTelemetry Documentation</h3>

        <table>
            <thead>
                <tr><th>Topic</th><th>URL</th></tr>
            </thead>
            <tbody>
                <tr><td>Observability Primer</td><td><a href="https://opentelemetry.io/docs/concepts/observability-primer/">opentelemetry.io/docs/concepts/observability-primer/</a></td></tr>
                <tr><td>Specification Overview</td><td><a href="https://opentelemetry.io/docs/specs/otel/overview/">opentelemetry.io/docs/specs/otel/overview/</a></td></tr>
                <tr><td>Logs in OpenTelemetry</td><td><a href="https://opentelemetry.io/docs/specs/otel/logs/">opentelemetry.io/docs/specs/otel/logs/</a></td></tr>
                <tr><td>Getting Started</td><td><a href="https://opentelemetry.io/docs/getting-started/">opentelemetry.io/docs/getting-started/</a></td></tr>
                <tr><td>Collector</td><td><a href="https://opentelemetry.io/docs/collector/">opentelemetry.io/docs/collector/</a></td></tr>
                <tr><td>Language SDKs</td><td><a href="https://opentelemetry.io/docs/languages/">opentelemetry.io/docs/languages/</a></td></tr>
            </tbody>
        </table>

        <h3>Observability Backends (OTel-compatible)</h3>

        <ul>
            <li><strong>Jaeger</strong>: <a href="https://www.jaegertracing.io/">jaegertracing.io</a> (distributed tracing)</li>
            <li><strong>Prometheus</strong>: <a href="https://prometheus.io/">prometheus.io</a> (metrics)</li>
            <li><strong>Grafana</strong>: <a href="https://grafana.com/">grafana.com</a> (visualization)</li>
            <li><strong>Loki</strong>: <a href="https://grafana.com/oss/loki/">grafana.com/oss/loki/</a> (log aggregation)</li>
        </ul>
    </section>

</main>

<footer>
    MCP Logging and Observability — AI Design Course, University of Trento
    <br><span style="font-size: 0.85em;">Content by Fabio Casati · <a href="https://www.linkedin.com/in/sphoebs/">LinkedIn</a> · <a href="https://x.com/sphoebs">X</a></span>
</footer>

<script>
    hljs.highlightAll();

    // Highlight current section in nav
    const sections = document.querySelectorAll('section[id], .title-section');
    const navLinks = document.querySelectorAll('nav a');

    window.addEventListener('scroll', () => {
        let current = 'intro';
        sections.forEach(section => {
            const sectionTop = section.offsetTop;
            if (scrollY >= sectionTop - 200) {
                current = section.getAttribute('id') || 'intro';
            }
        });

        navLinks.forEach(link => {
            link.classList.remove('active');
            if (link.getAttribute('href') === '#' + current) {
                link.classList.add('active');
            }
        });
    });
</script>

</body>
</html>
